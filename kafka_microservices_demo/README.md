MET CS 777 — Kafka Microservices Architecture Demo  
Authors: Aryaman Jalali & Aditya Kocherlakota  

----------------------------------------------------------------------
ENVIRONMENT SETUP
----------------------------------------------------------------------

System Requirements:
- macOS 14+ / Windows / Linux
- VS Code with integrated terminal
- Docker Desktop v4.32+
- Python 3.12+
- Kafka-python for event publishing and consumption

Python Libraries:
pip install kafka-python

Docker Configuration:
Kafka and Zookeeper are defined in docker-compose.yml.

services:
  zookeeper:
    image: confluentinc/cp-zookeeper:7.6.1
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"

  kafka:
    image: confluentinc/cp-kafka:7.6.1
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1

Start the services:
docker compose up -d

----------------------------------------------------------------------
HOW TO RUN THE CODE
----------------------------------------------------------------------

This demo simulates an e-commerce microservices workflow with event-driven communication between Order, Payment, and Notification services.

Run each service in its own terminal:

1. Order Service (publishes new orders):
   python order_service.py

2. Payment Service (consumes orders, processes payments):
   python payment_service.py

3. Notification Service (sends user notifications):
   python notification_service.py

Expected Flow:
- Order Service publishes ‘order_created’ messages.
- Payment Service consumes them, simulates success/failure, and sends ‘payment_processed’.
- Notification Service consumes payment events and prints success/failure messages.

----------------------------------------------------------------------
CODE SNIPPETS
----------------------------------------------------------------------

Order Service:
order = {
  "order_id": 1001,
  "user_id": random.randint(1, 100),
  "amount": round(random.uniform(10.0, 500.0), 2),
  "status": "created"
}
producer.send('order_topic', value=order)

Payment Service:
payment = {
  "order_id": order["order_id"],
  "status": random.choice(["payment_successful", "payment_failed"])
}
producer.send('payment_topic', value=payment)

Notification Service:
if status == "payment_successful":
  print(f"✅ Payment Successful for Order {payment['order_id']}")
else:
  print(f"❌ Payment Failed for Order {payment['order_id']}")

----------------------------------------------------------------------
DATASET EXPLANATION
----------------------------------------------------------------------

Dataset Type:
Synthetic e-commerce transaction stream generated dynamically.

Data Flow:
Each order event contains:
{
  "order_id": 1002,
  "user_id": 37,
  "amount": 199.99,
  "status": "payment_successful"
}

Fields:
- order_id: Incremental integer starting from 1000
- user_id: Random integer between 1–100
- amount: Random purchase amount between $10–$500
- status: Randomly assigned as “payment_successful” or “payment_failed”

Dataset can be regenerated by simply running the order_service.py.

----------------------------------------------------------------------
SUMMARY
----------------------------------------------------------------------

This demo shows:
- Event-driven microservices using Kafka
- Producer/Consumer pattern across independent services
- Fault-tolerant messaging between Order, Payment, and Notification
- Local Confluent Kafka 7.6.1 setup with Docker for reproducibility
